---
title: "Leading Variables and Associated Variables"
subtitle: "Chapter 3: Lesson 1"
format: html
editor: source
sidebar: false
---

```{r}
#| include: false
#this is a sourced file in the textbook. since some of the functions are referenced I needed to include the whole thing here when sharing.
# Load packages ----

if (!require("pacman")) install.packages("pacman")
pacman::p_load(MASS, # MVNorm, loaded before tidyverse so it doesn't overwrite dplyr::select()
               tidyverse, kableExtra,
               tsibble, fable,
               feasts, tsibbledata,
               fable.prophet,
               patchwork,
               ggthemes,
               see,   # okabeito color scheme
               ggokabeito, # colorblind palette
               stringr, # string manipulation
               lubridate, # date manipulation
               rio, # for easy i/o
               tidyquant,
               gt # grammar of tables, for LaTeX in tables
)
################# WARNING: DO NOT USE mosaic. IT MESSES UP THE DECOMPOSITION.

# Palette ----
palette("okabeito")

okabeito_colors_list <- c(
  `orange` = "#E69F00",
  `light blue` = "#56B4E9",
  `green` = "#009E73",
  `yellow` = "#F0E442",
  `blue` = "#0072B2",
  `red` = "#D55E00",
  `purple` = "#CC79A7",
  `grey` = "#999999",
  `black` = "#000000",
  `sky blue` = "#56B4E9",
  `bluish green` = "#009E73",
  `vermillion` = "#D55E00",
  `reddish purple` = "#CC79A7",
  `dark yellow` = "#F5C710",
  `amber` = "#F5C710"
)

# Rounding ----
## Round Dataframe ----
round_df <- function(df, digits) {
  nums <- vapply(df, is.numeric, FUN.VALUE = logical(1))
  df[,nums] <- round(df[,nums], digits = digits)
  (df)
}

# Used to create a table with ellipses in the middle

row_of_vdots <- function(df) {
  temp_df <- df |>
    # mutate(across(everything(), as.character)) |>
    head(1)

  for (j in 1:ncol(temp_df)) {
    if (names(temp_df[j]) == "sign") {
      temp_df[1,j] = " "
    } else {
      temp_df[1,j] = "⋮"
    }
  } # for

  return(temp_df)
}

concat_partial_table <- function(df, nrow_head, nrow_tail, decimals = 3) {
  temp_df <- convert_df_to_char(df, decimals)

  out_df <- head(temp_df, nrow_head) |>
    bind_rows(row_of_vdots(temp_df)) |>
    bind_rows(tail(temp_df, nrow_tail))

  return(out_df)
}

display_partial_table <- function(df, nrow_head, nrow_tail, decimals = 3, min_col_width = "0in") {
  concat_partial_table(df, nrow_head, nrow_tail, decimals) |>
    display_table(min_col_width)
}

display_table <- function(df, min_col_width = "0in") {
  df |>
    knitr::kable(format = "html", align='ccccccccccccccccc', escape = FALSE, width = NA, row.names = FALSE) |>
    kable_styling(full_width = FALSE, "striped") |>
    column_spec(1:ncol(df), width_min = min_col_width)
}

# Rounds a value to a specific number of places and returns a character string
round_as_text <- function(x, places) {
  return(as.character(round(x,12)))
}

# Converts a dataframe to char and rounds the values to a specified number of places
convert_df_to_char <- function(df, decimals = 3) {
  out_df <- df |>
    as.data.frame() |>
    mutate_if(is.numeric, round, digits=decimals) |>
    mutate(across(everything(), as.character))
  return(out_df)
}

# Change a df to character, round, and set one specific value to ""
blank_out_one_cell_in_df <- function(df, row_num, col_num, decimals = 3) {
  out_df <- df |>
    convert_df_to_char(decimals)

  out_df[row_num, col_num] <- ""

  return(out_df)
}

# Returns "" for all cells except the first ncols_to_keep columns and nrows_to_keep rows
# Numeric values are rounded to "decimals" places
blank_out_cells_in_df <- function(df, ncols_to_keep = 2, nrows_to_keep = 0, decimals = 3) {
  out_df <- df |>
    convert_df_to_char(decimals)

  for (i in (nrows_to_keep + 1) : nrow(df))
    for (j in (ncols_to_keep + 1) : ncol(df)) {
      out_df[i,j] <- ""
    }
  return(out_df)
}


# Returns "" for all cells except the first ncols_to_keep columns and nrows_to_keep rows
# Numeric values are rounded to "decimals" places
blank_out_partial_row <- function(df, row_number = nrow(df), first_column_number = 2, last_column_number = ncol(df), decimals = 3) {
  out_df <- df |>
    convert_df_to_char(decimals)

  for (j in first_column_number:last_column_number) {
    out_df[row_number,j] <- ""
  }

  return(out_df)
}


###### Compute sum or mean of numeric variables in a df

append_sum_to_df <- function(df, label = "Sum") {
  df <- df %>%
    bind_rows(summarise_all(., ~if(is.numeric(.)) sum(., na.rm = TRUE) else label))
  return(df)
}

append_mean_to_df <- function(df, label = "Mean") {
  df <- df %>%
    bind_rows(summarise_all(., ~if(is.numeric(.)) mean(., na.rm = TRUE) else label))
  return(df)
}

sum_of_columns <- function(df, label = "Sum") {
  row <- df %>%
    summarise_all(., ~if(is.numeric(.)) sum(., na.rm = TRUE) else label)
  return(row)
}

mean_of_columns <- function(df, label = "Mean") {
  row <- df %>%
    summarise_all(., ~if(is.numeric(.)) mean(., na.rm = TRUE) else label)
  return(row)
}

sum_of_columns_divided_by_n <- function(df, label, n = nrow(df)) {
  row <- df %>%
    summarise_all(., ~if(is.numeric(.)) sum(., na.rm = TRUE)/n else label)
  return(row)
}



insert_blank_last_row <- function(df, label = "sum", value = "", decimals = 3) {
  temp_df <- df |>
    bind_rows(df |> tail(1))
  convert_df_to_char(decimals)
  num_rows <- nrow(temp_df)
  temp_df[num_rows, ] <- value
  temp_df[num_rows, 1] <- label
  return(temp_df)
}


########### Compute moving average
compute_moving_average <- function(df, variable, periods = 12) {
  sum <- 0

  for (i in 1:(periods / 2)) {
    sum <- sum + lead(eval(substitute(variable), df), i)           # x_{t+i}
    sum <- sum + lag(eval(substitute(variable), df), i)            # x_{t-i}
  }
  sum <- sum + eval(substitute(variable), df)
  sum <- sum - lag(eval(substitute(variable), df), periods / 2) / 2
  sum <- sum - lead(eval(substitute(variable), df), periods / 2) / 2
  df$m_hat <- sum / periods
  return(df)
}

# # # # # # # # # # # # # Testing
# set.seed(1)
# x <- rnorm(100,5,2)
# df1 <- data.frame(x=x)
#
# df1 |>
#   compute_moving_average(x, 12) |>
# mutate( m_hat2 =
#           ( 1 / 2 * lag(x,6) + lag(x,5) + lag(x,4) + lag(x,3) + lag(x,2) + lag(x) + x + lead(x,1) + lead(x,2) + lead(x,3) + lead(x,4) + lead(x,5) + 1 / 2 * lead(x,6)) /12
# ) |> View()


########### String manipulation

# Returns "char" right-most characters of "string"
right <- function (string, char) {
  substr(string, nchar(string)-(char-1), nchar(string))
}

# Returns "char" left-most characters of "string"
left <- function (string, char) {
  substr(string, 1, char)
}

##########################################################################
# These functions color cells in a data frame of character vectors
# Works
color_specific_cell <- function(df, row_num, col_num, color) {
  df[row_num, col_num] = cell_spec(df[row_num, col_num], color = color)
  return(df)
}

# -------- THIS ONE IS NOT WORKING ----------
color_specific_row <- function(df, row_num, color) {
  for (j in 1:ncol(df)) {
    color_specific_cell(df, row_num, j, color)
  }
  return(df)
}

# -------- THIS ONE IS NOT WORKING ----------
color_last_row <- function(df, color) {
  color_specific_row(df, nrow(df), color)
  return(df)
}

# Works
color_last_row2 <- function(df, color) {
  for (j in 1:ncol(df)) {
    df[nrow(df), j] = cell_spec(df[nrow(df), j], color = color)
  }
  return(df)
}
# Works
color_2nd_to_last_row2 <- function(df, color) {
  for (j in 1:ncol(df)) {
    df[nrow(df)-1, j] = cell_spec(df[nrow(df)-1, j], color = color)
  }
  return(df)
}
##########################################################################



#############################################

#

get_toy_data <- function(n = 10, mu = 0, sigma = 3, rho = 0.99, random_seed = 997) {
  set.seed(random_seed)

  # build population correlation matrix
  tmp.r <- matrix(rho, n, n)
  tmp.r <- tmp.r^abs(row(tmp.r)-col(tmp.r))

  return( round(mvrnorm(1, rep(mu,n), sigma^2 * tmp.r),1) )
}


#############################################

deg2rad <- function (x)
{
  x/180 * base::pi
}

rad2deg <- function (x)
{
  x/base::pi * 180
}




################## Holt-Winters ####################

holt_winters_additive_forecast <- function(data, value_var, alpha = 0.2, beta = 0.2, gamma = 0.2, p = 12, a1 = NULL, b1 = NULL, s1 = NULL) {
  # Assuming 'data' is a tsibble with a column 'value'
  at <- numeric(nrow(data))
  bt <- numeric(nrow(data))
  st <- numeric(nrow(data))

  at[1] <- ifelse(!is.null(a1), a1, data[[value_var]][1])
  bt[1] <- ifelse(!is.null(b1), b1, (1 / p) * mean( data[[value_var]][(p+1):(2*p)] - data[[value_var]][1:p] ))
  st[1:p] <- ifelse(!is.null(s1), s1, 0)

  # First cycle
  for (t in 2:p) {
    at[t] <- alpha * (data[[value_var]][t] - st[t - 0 * p ]) + (1 - alpha) * (at[t - 1] + bt[t - 1])
    bt[t] <- beta * (at[t] - at[t - 1]) + (1 - beta) * bt[t - 1]
  }

  for (t in (p + 1):nrow(data)) {
    at[t] <- alpha * (data[[value_var]][t] - st[t - p]) + (1 - alpha) * (at[t - 1] + bt[t - 1])
    bt[t] <- beta * (at[t] - at[t - 1]) + (1 - beta) * bt[t - 1]
    st[t] <- gamma * (data[[value_var]][t] - at[t]) + (1 - gamma) * st[t - p]
  }

  data <- data %>%
    mutate(estimated_level = at, estimated_slope = bt, estimated_seasonal = st)

  data %>% return()
}
```

```{=html}
<script type="text/javascript">
 function showhide(id) {
    var e = document.getElementById(id);
    e.style.display = (e.style.display == 'block') ? 'none' : 'block';
 }
 
 function openTab(evt, tabName) {
    var i, tabcontent, tablinks;
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
    }
    document.getElementById(tabName).style.display = "block";
    evt.currentTarget.className += " active";
 }    
</script>
```


<!-- Check Your Understanding -->

<!-- ::: {.callout-tip icon=false title="Check Your Understanding"} -->


```{r}
#| include: false

set.seed(2887) # Gives integer mean for y
n <- 10
k <- 2

# x <- c(17, 18, 21, 23, 16, 17, 20, 23, 24, 21, 18, 17)

x <- rep(20, n + k)
for(i in 2:length(x)) {
  x[i] = x[i-1] + sample(-3:3, 1)
}

z <- sample(-2:2, n + k, replace = TRUE)
toy_df <- data.frame(x = x, z = z) |>
  mutate(y = round(1.5 * lag(x, k) + z - 15), 0) |>
  mutate(t = row_number()) |>
  na.omit() |>
  dplyr::select(t, x, y)

# mean(toy_df$x)
# mean(toy_df$y)

toy_ts <- toy_df |>
  mutate(
    dates = yearmonth( my(paste(row_number(), year(now()) - 1) ) )
  ) |>
  as_tsibble(index = dates)

toy_ts |>
  autoplot(.vars = x) +
  geom_line(data = toy_ts, aes(x = dates, y = y), color = "#E69F00") +
    labs(
      x = "Time",
      y = "Value of x (in black) and y (in orange)",
      title = paste0("Two Time Series Illustrating a Lag")
    ) +
    theme(
      plot.title = element_text(hjust = 0.5)
    )
  
```

Complete Tables 1 and 2 to calculate $c_k$ for the given values of $k$.

```{r}
#| echo: false

make_ck_table <- function (df) {
  temp <- df |>
    mutate(t = as.character(row_number())) |>
    mutate(xx = x - mean(x)) |>
    mutate(xx2 = (x - mean(x))^2) |>
    mutate(yy = y - mean(y)) |>
    mutate(yy2 = yy^2) |>
    mutate(x_4y = (lag(x,4) - mean(x)) * (y - mean(y))) |>
    mutate(x_3y = (lag(x,3) - mean(x)) * (y - mean(y))) |>
    mutate(x_2y = (lag(x,2) - mean(x)) * (y - mean(y))) |>
    mutate(x_1y = (lag(x,1) - mean(x)) * (y - mean(y))) |>
    mutate(x0y = (lag(x,0) - mean(x)) * (y - mean(y))) |>
    mutate(x1y = (lead(x,1) - mean(x)) * (y - mean(y))) |>
    mutate(x2y = (lead(x,2) - mean(x)) * (y - mean(y))) |>
    mutate(x3y = (lead(x,3) - mean(x)) * (y - mean(y))) |>
    mutate(x4y = (lead(x,4) - mean(x)) * (y - mean(y)))
  
  c0xx_times_n <- sum(temp$xx2)
  c0yy_times_n <- sum(temp$yy2)
  sum <- sum_of_columns(temp)
  c_k <- sum_of_columns_divided_by_n(temp, "$$c_k$$")
  r_k <- sum_of_columns_divided_by_n(temp, "$$r_k$$", sqrt(c0xx_times_n * c0yy_times_n))
  
  out_df <- temp |>
    bind_rows(sum) |>
    bind_rows(c_k) |>
    bind_rows(r_k) |>
    convert_df_to_char() |>
    mutate_if(is.character, replace_na, "—") |>
    rename(
      "$$t$$" = t,
      "$$x_t$$" = x,
      "$$y_t$$" = y,
      "$$x_t - \\bar x$$" = xx,
      "$$(x_t - \\bar x)^2$$" = xx2,
      "$$y_t - \\bar y$$" = yy,
      "$$(y_t - \\bar y)^2$$" = yy2,
      "$$~k=-4~$$" = x_4y,
      "$$~k=-3~$$" = x_3y,
      "$$~k=-2~$$" = x_2y,
      "$$~k=-1~$$" = x_1y,
      "$$~k=0~$$" = x0y,
      "$$~k=1~$$" = x1y,
      "$$~k=2~$$" = x2y,
      "$$~k=3~$$" = x3y,
      "$$~k=4~$$" = x4y
    ) %>% 
    blank_out_one_cell_in_df(row_num = nrow(.)-1, col_num = 2) %>% 
    blank_out_one_cell_in_df(row_num = nrow(.)-1, col_num = 3) %>% 
    blank_out_one_cell_in_df(row_num = nrow(.)-1, col_num = 4) %>% 
    blank_out_one_cell_in_df(row_num = nrow(.)-1, col_num = 5) %>% 
    blank_out_one_cell_in_df(row_num = nrow(.)-1, col_num = 6) %>% 
    blank_out_one_cell_in_df(row_num = nrow(.)-1, col_num = 7) %>% 
    blank_out_one_cell_in_df(row_num = nrow(.), col_num = 2) %>% 
    blank_out_one_cell_in_df(row_num = nrow(.), col_num = 3) %>% 
    blank_out_one_cell_in_df(row_num = nrow(.), col_num = 4) %>% 
    blank_out_one_cell_in_df(row_num = nrow(.), col_num = 5) %>% 
    blank_out_one_cell_in_df(row_num = nrow(.), col_num = 6) %>% 
    blank_out_one_cell_in_df(row_num = nrow(.), col_num = 7) 
  
  return(out_df)
}

toy_solution <- make_ck_table(toy_df)
```

#### Table 1: Computation of squared deviations

```{r}
#| echo: false

toy_solution_temp <- toy_solution[,1:7] |> 
  head(-2) |> 
  blank_out_cells_in_df(ncols_to_keep = 5, nrows_to_keep = 0)
toy_solution_temp |> display_table()
```

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

#### Table 2: Computation of $c_k$ and $r_k$ for select values of $k$

```{r}
#| echo: false

temp_df <- toy_solution[,c(1,4,6,8:16)] 
temp_df[,4:9] <- ""
temp_df <- temp_df |> 
  blank_out_cells_in_df(ncols_to_keep = 3, nrows_to_keep = 10) 
temp_df[1,8] <- "-1"
temp_df |> 
  display_table()
```



<!-- -   Use the figure below as a guide to plot the ccf values. -->

#### Figure 2: Plot of the Sample CCF

```{r, fig.width=6, fig.asp=0.6, fig.align='center'}
#| echo: false

df <- data.frame(x = -4:4)
ggplot(data = df, aes(x = x, y = acf(x, plot = FALSE)$acf)) +
  # geom_col() +
  ylim(-1, 1) +
  scale_x_continuous(breaks = -4:4) + 
  # geom_segment(aes(x = 0, y = 0, xend = -4, yend = 1)) + 
  # geom_segment(aes(x = 0, y = 0, xend = 4, yend = 0)) + ## Hack
  geom_hline(yintercept = 0, linetype = "solid", linewidth=1, color = "black") +
  geom_hline(yintercept = (0.62), linetype = "dashed", linewidth=1, color = "#0072B2") +  # Texbooks says these lines should be at (-0.1 +/- 2/sqrt(10)). Used +/-(2.6/4.2), based on measurements made visually with a ruler from the figure generated by R.
  geom_hline(yintercept = (-0.62), linetype = "dashed", linewidth=1, color = "#0072B2") +
  labs(x = "Lag", y = "CCF") +
  # theme_bw()   
  # theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank())
  theme_bw() +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank()
  )
```

<!-- -   Are any of the ccf values statistically significant? If so, which one(s)? -->

<!-- ::: -->

